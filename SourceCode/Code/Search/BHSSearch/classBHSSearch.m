/*==================================================================================================================*
 *                                                                                                                  *
 *                                               classBHSSearch                                                     *
 *                                               ==============                                                     *
 *                                                                                                                  *
 *  All methods relating to performing and managing the search function.                                            *
 *                                                                                                                  *
 *  Since the processing is quite convoluted, this summary constitutes a road-map of methods.                       *
 *                                                                                                                  *
 *  Following the more obvious, global variables, we define:                                                        *
 *    a) searchThread: what will be a background thread performing the actual search;                               *
 *    b) definition of a number of delegates                                                                        *
 *    c) the procedures that implement the delegates.                                                               *
 *  These are:                                                                                                      *
 *                                                                                                                  *
 *     Delegate                    Related Procedure                                                                *
 *     --------                    -----------------                                                                *
 *                                                                                                                  *
 *   performGroupboxAddition       addGroupbox                                                                      *
 *   performCheckboxAddition       addCheckbox                                                                      *
 *   performToolStripMessage       displayToolStripMessage     Display messages in the tool bar of the search area  *
 *   controlMTBaseSearch                                                                                            *
 *   controlLXXBaseSearch                                                                                           *
 *                                                                                                                  *
 *  These are followed by:                                                                                          *
 *                                                                                                                  *
 *   classSearch                   The initialising method for the class.                                           *
 *                                 Slave methods:                                                                   *
 *                                   searchOptionCheckedChanged         Called when a checkbox value is changed     *
 *                                                                                                                  *
 *  Other "setup" procedures are generated by buttons in the lower right Search tabs.  These are:                   *
 *                                                                                                                  *
 *     Form Button                           Procedure                                                              *
 *     -----------                           ---------                                                              *
 *                                                                                                                  *
 *   Main menu - Set Search Details       searchSetup                                                               *
 *                                          slave method:  hideOrShowAdvancedSearch                                 *
 *   Advanced Search button               setSearchType                                                             *
 *                                                                                                                  *
 *  The main form class will call the following method when either of the "Perform Search" buttons are clicked:     *
 *                                                                                                                  *
 *   controlSearch                                                                                                  *
 *                                                                                                                  *
 *  This, in turn, will call the following background task:                                                         *
 *                                                                                                                  *
 *   threadControl                                                                                                  *
 *                                                                                                                  *
 *  From this point on the background sequence will be as follows:                                                  *
 *                                                                                                                  *
 *         Masoretic Text (currentVersion = 0)                       Septuagint (currentVersion = 1)                *
 *         -----------------------------------                       -------------------------------                *
 *                                                                                                                  *
 *       mtBaseSearch  ->                                         lxxBaseSearch ->                                  *
 *          initialMTMatchProcessing                              initialLXXMatchProcessing                         *
 *          primaryMTScan                                         primaryLXXScan                                    *
 *          secondaryMTScan                                       secondaryLXXScan                                  *
 *          isThereAnMTMatch -> removeNonConsonents               isThereAnLXXMatch                                 *
 *          mtVerifyWord -> getStrongRefs                         lxxVerifyWord                                     *
 *          displayMTResults                                      displayLXXResults                                 *
 *                                                                                                                  *
 *                                                                                                                  *
 *                                                                                                                  *
 *  The following methods are used in the display processing by both MT and LXX:                                    *
 *                                                                                                                  *
 *    initialSetupOfRText      initial setup of a created RichTextBox                                               *
 *    getNewRTXHeight          Get the height of the text written to a RichTextBox                                  *
 *    resetRTX                 Reset the height of both RichTextBoxes in a given row                                *
 *                                                                                                                  *
 *  Created: Len Clark                                                                                              *
 *  May 2022                                                                                                        *
 *                                                                                                                  *
 *==================================================================================================================*/

#import "classBHSSearch.h"

@implementation classBHSSearch

@synthesize bhsSearchLoop;
@synthesize labBHSSearchProgressLbl;
@synthesize primaryBHSWord;
@synthesize secondaryBHSWord;
@synthesize bhsWithin;
@synthesize bhsSteps;
@synthesize bhsStepper;
@synthesize bhsWordsOf;

@synthesize isSearchSuccessful;
@synthesize isWordGiven;
@synthesize isSWordGiven;
@synthesize noOfMatchingBHSVerses;
@synthesize currentVersion;
@synthesize currentSearchType;
@synthesize matchType;
@synthesize noOfRTXLines;
@synthesize noOfAllMatches;
@synthesize listOfBHSPrimaryResults;
@synthesize allBHSMatches;
@synthesize booksToInclude;
@synthesize strongRefs;
@synthesize SecondStrongRefs;
@synthesize storeReference;
@synthesize storeText;

classGlobal *globalVarsBHSSearch;
classHebLexicon *searchHebrewLexicon;
classBHSText *searchBHSText;

/*=======================================================================================*
 *                                                                                       *
 *  The following variables support the use of performing the display as a background    *
 *    process, using NSThread.  (Note: I tried NSOperations but this seems to be         *
 *    designed for multiple processes and how to continue using the main task wasn't     *
 *    obvious, although, I'm sure, with a bit more effort on my part, it would be a      *
 *    better solution.)                                                                  *
 *                                                                                       *
 *  The driver for using a background task is that search tasks can take a long time -   *
 *    especially complex searches.  Using a background task is not only better coding    *
 *    but also allows the creation of a "stop" button to interrupt the search.           *
 *                                                                                       *
 *=======================================================================================*/
NSInteger  bhsDisplayAlignment, bhsLatestResultCount, bhsRunningResultCount;
NSString *bhsProgressMessage;
NSThread *bhsBackgroundThread;
NSTimer *bhsDisplayTimer;
NSMutableDictionary *bhsSearchResults;
NSTextView *bhsResultsTextView;

- (id) init: (classGlobal *) inGlobal forHebLexicon: (classHebLexicon *) inHebLex forHebText: (classBHSText *) inBHSText andLoop: (NSRunLoop *) inLoop //withNotes: (classNote *) inNote
{
    if( self = [super init])
    {
        globalVarsBHSSearch = inGlobal;
        searchBHSText = inBHSText;
        searchHebrewLexicon = inHebLex;
        bhsSearchLoop = inLoop;
        
        isSearchSuccessful = false;
        matchType = 0;
        noOfAllMatches = 0;
        listOfBHSPrimaryResults = [[NSMutableDictionary alloc] init];
        allBHSMatches = [[NSMutableDictionary alloc] init];
        booksToInclude = [[NSMutableArray alloc] init];
        strongRefs = [[NSMutableArray alloc] init];
        SecondStrongRefs = [[NSMutableArray alloc] init];
        labBHSSearchProgressLbl = [globalVarsBHSSearch labSearchProgress];
    }
    return self;
}

- (void) searchSetup: (NSInteger) tagVal
{
    /*==================================================================================================================*
     *                                                                                                                  *
     *                                                searchSetup                                                       *
     *                                                ===========                                                       *
     *                                                                                                                  *
     *  Additional setup actions, depending on whether Primary or Secondary word.                                       *
     *                                                                                                                  *
     *  tagVal   1 = primary, 2 = secondary                                                                             *
     *                                                                                                                  *
     *==================================================================================================================*/
    NSInteger comboboxIndex;
    NSString *searchWord;
    NSTextField *targetTextField;
    NSTabView *targetTab;
    NSComboBox *cbBook, *cbChapter, *cbVerse;
    
    cbBook = [globalVarsBHSSearch cbBHSBook];
    cbChapter = [globalVarsBHSSearch cbBHSChapter];
    cbVerse = [globalVarsBHSSearch cbBHSVerse];
    switch (tagVal)
    {
        case 0:
            // Add the last selected word to the primary text box
            searchWord = [[NSString alloc] initWithString:[searchHebrewLexicon removeAccents:[globalVarsBHSSearch latestSelectedBHSWord]]];
            targetTextField = [globalVarsBHSSearch txtBHSPrimaryWord];
            [targetTextField setStringValue:searchWord];
            comboboxIndex = [cbBook indexOfSelectedItem];
            [globalVarsBHSSearch setPrimaryBHSBookId:comboboxIndex];
            comboboxIndex = [cbChapter indexOfSelectedItem];
            [globalVarsBHSSearch setPrimaryBHSChapNo:[[NSString alloc] initWithString:[cbChapter itemObjectValueAtIndex:comboboxIndex]]];
            comboboxIndex = [cbVerse indexOfSelectedItem];
            [globalVarsBHSSearch setPrimaryBHSVNo:[[NSString alloc] initWithString:[cbVerse itemObjectValueAtIndex:comboboxIndex]]];
            [globalVarsBHSSearch setPrimaryBHSWordSeq:[globalVarsBHSSearch sequenceOfLatestBHSWord]];
            [globalVarsBHSSearch setPrimaryBHSWord:[globalVarsBHSSearch latestSelectedBHSWord]];
            break;
        case 1:
            searchWord = [[NSString alloc] initWithString:[searchHebrewLexicon removeAccents:[globalVarsBHSSearch latestSelectedBHSWord]]];
            targetTextField = [globalVarsBHSSearch txtBHSSecondaryWord];
            [targetTextField setStringValue:searchWord];
            comboboxIndex = [cbBook indexOfSelectedItem];
            [globalVarsBHSSearch setSecondaryBHSBookId:comboboxIndex];
            comboboxIndex = [cbChapter indexOfSelectedItem];
            [globalVarsBHSSearch setSecondaryBHSChapNo:[[NSString alloc] initWithString:[cbChapter itemObjectValueAtIndex:comboboxIndex]]];
            comboboxIndex = [cbVerse indexOfSelectedItem];
            [globalVarsBHSSearch setSecondaryBHSVNo:[[NSString alloc] initWithString:[cbVerse itemObjectValueAtIndex:comboboxIndex]]];
            [globalVarsBHSSearch setSecondaryBHSWordSeq:[globalVarsBHSSearch sequenceOfLatestBHSWord]];
            [globalVarsBHSSearch setSecondaryBHSWord:[globalVarsBHSSearch latestSelectedBHSWord]];
            [self hideOrShowAdvancedSearch:false];
            break;
    }
    targetTab = [globalVarsBHSSearch tabUtilities];
    [targetTab selectTabViewItemAtIndex:0];
    targetTab = [globalVarsBHSSearch tabBHSUtilityDetail];
    [targetTab selectTabViewItemAtIndex:1];
}

- (void) hideOrShowAdvancedSearch: (bool) isToShow
{
    NSTextField *label, *textBox, *steps;
    NSButton *searchButton;
    NSStepper *stepper;
    
    label = [globalVarsBHSSearch labBHSWordsOfLbl];
    [label setHidden:isToShow];
    [[globalVarsBHSSearch stepperBHSScan] setHidden:isToShow];
    label = [globalVarsBHSSearch labBHSWithinLbl];
    [label setHidden:isToShow];
    textBox = [globalVarsBHSSearch txtBHSSecondaryWord];
    [textBox setHidden:isToShow];
    stepper = [globalVarsBHSSearch stepperBHSScan];
    [stepper setHidden:isToShow];
    steps = [globalVarsBHSSearch bhsSteps];
    [steps setHidden:isToShow];
    searchButton = [globalVarsBHSSearch btnBHSAdvanced];
    if( isToShow) [searchButton setTitle:@"Advanced Search"];
    else [searchButton setTitle:@"Basic Search"];
}

- (void) controlSearch
{
    /*======================================================================================================*
     *                                                                                                      *
     *                                           controlSearch                                              *
     *                                           =============                                              *
     *                                                                                                      *
     *  Key variables used in the procedure:                                                                *
     *  -----------------------------------                                                                 *
     *                                                                                                      *
     *  searchType          Indicates whether the search is "simple" (a single word) or "complex" (one word *
     *                      withing n words of a second). The identification is based on whether lblWithin  *
     *                      is visible or not.                                                              *
     *                      Values of searchType are:                                                       *
     *                        simple:   1                                                                   *
     *                        complex:  2                                                                   *
     *  matchType           The type of matching strategy, as determined by the radio button selected.      *
     *                      Values and significances are:                                                   *
     *                        1    matching is based on BDB Refs.                                           *
     *                        2    matching is "moderate" - based on consonents only                        *
     *                        3    matching is "strict" - both consonents and vowels must match             *
     *                                                                                                      *
     *  Processing:                                                                                         *
     *  ==========                                                                                          *
     *                                                                                                      *
     *  The ultimate purpose of this method (together with its subsidiary methods) is to populate a series  *
     *    of classSearchResults instances, all of which are stored (temporariy) in the global list,         *
     *    currentSearchResults.  These can then be interrogated by the separate method that actually        *
     *    displays them.                                                                                    *
     *                                                                                                      *
     *======================================================================================================*/

    /*------------------------------------------------------------------------------------------------------*
     *                                                                                                      *
     *  Constants:                                                                                          *
     *  ---------                                                                                           *
     *                                                                                                      *
     *  zeroWidthSpace      Used to mark the start of a word (making identification of words easier)        *
     *  zeroWidthNonJoiner  Separates the base word from prefixed "words" such as vav and prepositions      *
     *  noBreakSpace        Used in references to avoid breaking across references and other odd changes    *
     *  ideographicSpace    Used in book names that contain spaces (so we can keep book names intact)       *
     *                                                                                                      *
     *------------------------------------------------------------------------------------------------------*/

    BOOL stateCheck;
    NSInteger idx, noOfBooks = 0;
    NSString *searchWord, *secondarySearchWord;
    NSButton *btnInclude;
    NSTextField *label, *textBox;
    NSButton *radioButton;
    NSArray *listboxData;
    classBHSBook *currentBHSBook;
    classAlert *alert;

    matchType = 0;
    isWordGiven = false;
    isSWordGiven = false;

    /*----------------------------------------------------------------------------------------------*
     * Provide initial progress information in the tool strip below the search results area.        *
     *----------------------------------------------------------------------------------------------*/
    [labBHSSearchProgressLbl setStringValue:@"Performing your search"];
    [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];

    [booksToInclude removeAllObjects];
    booksToInclude = [[NSMutableArray alloc] init];

    /*----------------------------------------------------------------------------------------------*
     * Check whether the search is "simple" or "complex"                                            *
     *   Set searchType accordingly, then invoke lexicon.performSearch as suitable                  *
     *----------------------------------------------------------------------------------------------*/
    textBox = [globalVarsBHSSearch txtBHSPrimaryWord];
    if( [[textBox stringValue] length] == 0)
    {
        alert = [[classAlert alloc] init];
        [alert messageBox:@"You have selected a Search with no Primary word" title:@"Search Error" boxStyle:NSAlertStyleWarning];
        return;
    }
    label = [globalVarsBHSSearch labBHSWordsOfLbl];
    if ([label isHidden]) currentSearchType = 1;
    else
    {
        textBox = [globalVarsBHSSearch txtBHSSecondaryWord];
        if( [[textBox stringValue] length] == 0)
        {
            alert = [[classAlert alloc] init];
            [alert messageBox:@"You have selected an Advanced with no Secondary word" title:@"Search Error" boxStyle:NSAlertStyleWarning];
            return;
        }
        currentSearchType = 2;
    }

    /*----------------------------------------------------------------------------------------------*
     * Record the search type: based on BDB matches, strict or moderate.                            *
     *----------------------------------------------------------------------------------------------*/
    radioButton = [globalVarsBHSSearch rbtnBDBRefs];
    if( [radioButton state] == NSControlStateValueOn) matchType = 1;
    else
    {
        radioButton = [globalVarsBHSSearch rbtnBHSStrict];
        if( [radioButton state] == NSControlStateValueOn) matchType = 2;
        else
        {
            radioButton = [globalVarsBHSSearch rbtnBHSModerate];
            if( [radioButton state] == NSControlStateValueOn) matchType = 3;
        }
    }
    btnInclude = [globalVarsBHSSearch rbtnBHSExclude];
    noOfBooks = [globalVarsBHSSearch noOfBHSBooks];
    for (idx = 0; idx < noOfBooks; idx++)
    {
        // Is the current book in the list to be searched?
        currentBHSBook = nil;
        currentBHSBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString: idx]];
        listboxData = [[NSArray alloc] initWithArray:(NSArray *)[globalVarsBHSSearch bhsAvailableBooksMaster]];
        if ([btnInclude state] == NSControlStateValueOn)
        {
            if ( [listboxData containsObject:[currentBHSBook bookName]]) [booksToInclude addObject:[currentBHSBook bookName]];
        }
        else
        {
            if ( ! [listboxData containsObject:[currentBHSBook bookName]]) [booksToInclude addObject:[currentBHSBook bookName]];
        }
    }

    /*----------------------------------------------------------------------------------------------*
     * Perform a search in a background thread.                                                     *
     *----------------------------------------------------------------------------------------------*/
//    btnClose = (NSButton *)[searchGlobalVars getGroupedControl:[searchGlobalVars buttonsCode] atPosition:2];
//    [btnClose setHidden:false];
    switch (currentSearchType)
    {
        case 1:
            searchWord = [[NSString alloc] initWithString:[[globalVarsBHSSearch txtBHSPrimaryWord] stringValue]];
            btnInclude = [globalVarsBHSSearch rbtnBHSExclude];
            stateCheck = [btnInclude state] == NSControlStateValueOn;
            [self bhsBaseSearch:1
                     matchType:matchType
                   primaryBook:[globalVarsBHSSearch primaryBHSBookId]
                primarychapter:[globalVarsBHSSearch primaryBHSChapNo]
                  primaryVerse:[globalVarsBHSSearch primaryBHSVNo]
           primaryWordSequence:[globalVarsBHSSearch primaryBHSWordSeq]
                   primaryWord:searchWord
                 secondaryBook:-1
              secondaryChapter:@""
                secondaryVerse:@""
         secondaryWordSequence:-1
                 secondaryWord:@""
                    searchSpan:0
               whetherToInclude:stateCheck];
            break;
        case 2:
            searchWord = [[NSString alloc] initWithString:[[globalVarsBHSSearch txtBHSPrimaryWord] stringValue]];
            secondarySearchWord = [[NSString alloc] initWithString:[[globalVarsBHSSearch txtBHSSecondaryWord] stringValue]];
            btnInclude = [globalVarsBHSSearch rbtnBHSExclude];
            stateCheck = [btnInclude state] == NSControlStateValueOn;
            [self bhsBaseSearch:2
                     matchType:matchType
                   primaryBook:[globalVarsBHSSearch primaryBHSBookId]
                primarychapter:[globalVarsBHSSearch primaryBHSChapNo]
                  primaryVerse:[globalVarsBHSSearch primaryBHSVNo]
           primaryWordSequence:[globalVarsBHSSearch primaryBHSWordSeq]
                   primaryWord:searchWord
                 secondaryBook:[globalVarsBHSSearch secondaryBHSBookId]
              secondaryChapter:[globalVarsBHSSearch secondaryBHSChapNo]
                secondaryVerse:[globalVarsBHSSearch secondaryBHSVNo]
         secondaryWordSequence:[globalVarsBHSSearch secondaryBHSWordSeq]
                 secondaryWord:secondarySearchWord
                    searchSpan:[[[globalVarsBHSSearch bhsSteps] stringValue] integerValue]
               whetherToInclude:stateCheck];
            break;
    }
}

/*======================================================================================================*
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 *                                                                                                      *
 *                                      BHS Search Methods                                              *
 *                                      ==================                                              *
 *                                                                                                      *
 *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
 *======================================================================================================*/

- (void) bhsBaseSearch: (NSInteger) searchType
            matchType: (NSInteger) matchType
          primaryBook: (NSInteger) pBook
       primarychapter: (NSString *) pChap
         primaryVerse: (NSString *) pVerse
  primaryWordSequence: (NSInteger) pSeq
          primaryWord: (NSString *) pWord
        secondaryBook: (NSInteger) sBook
     secondaryChapter: (NSString *) sChap
       secondaryVerse: (NSString *) sVerse
secondaryWordSequence: (NSInteger) sSeq
        secondaryWord: (NSString *) sWord
           searchSpan: (NSInteger) searchSpan
      whetherToInclude: (bool) exclude_include
{
    /*===============================================================================================================*
     *                                                                                                               *
     *                                                bhsBaseSearch                                                  *
     *                                                =============                                                  *
     *                                                                                                               *
     *  Purpose:                                                                                                     *
     *  =======                                                                                                      *
     *                                                                                                               *
     *  To handle the search for both a basic search and an advanced (two-word) search.                              *
     *                                                                                                               *
     *  Parameters:                                                                                                  *
     *  ==========                                                                                                   *
     *    searchType   If this = 1, the search is basic; 2, the search is more complex                               *
     *    matchType    Possible values                                                                               *
     *                 and significance are:                                                                         *
     *                  Value                       Significance                                                     *
     *                    1     Matches are based on BDB References                                                  *
     *                    2     Matches are "moderate" - based on consonents only                                    *
     *                    3     Matches are "strict" - match both consonents and vowels                              *
     *       If the primary word has been populated from the main text (by a right click), then:                     *
     *    pBook        The bookId of the primary search source word                                                  *
     *    pChap        The chapter reference of the primary search source word                                       *
     *    pVerse       The verse reference of the primary search source word                                         *
     *    pSeq         The sequence in the verse of the primary search source word                                   *
     *    pWord        The actual primary word (without accents, with vowels)                                        *
     *       If the secondary word has been populated from the main text (by a right click), then:                   *
     *    sBook        The bookId of the secondary search source word                                                *
     *    sChap        The chapter reference of the secondary search source word                                     *
     *    sVerse       The verse reference of the secondary search source word                                       *
     *    sSeq         The sequence in the verse of the secondary search source word                                 *
     *    sWord        The actual secondary word (without accents, with vowels)                                      *
     *    searchSpan   An int value; the number of words before and after the matched word in which the secondary    *
     *                   word must occur for a full match.                                                           *
     *    exclude_include                                                                                            *
     *                 If = true, we *include* all in the listed book category                                       *
     *                 if = false, we include those *not* in the category                                            *
     *                                                                                                               *
     *  Returned variable:                                                                                           *
     *  =================                                                                                            *
     *    A String variable containing all/any search results                                                        *
     *                                                                                                               *
     *===============================================================================================================*/

    bool isWorthProgressing = false;

    [self initialBHSMatchProcessing:pBook
                     primarychapter:pChap
                       primaryVerse:pVerse
                primaryWordSequence:pSeq
                        primaryWord:pWord
                      secondaryBook:sBook
                   secondaryChapter:sChap
                     secondaryVerse:sVerse
              secondaryWordSequence:sSeq
                      secondaryWord:sWord];
    isWorthProgressing = isWordGiven;
    if ( (currentSearchType == 2) && (!isSWordGiven)) isWorthProgressing = false;
    if (isWorthProgressing)
    {
        // We now have an assured list of Strong references to the word.  Now hunt for all occurrences
        [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"Scanning the OT for uses of %@", pWord]];
        [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
        if (searchType == 1) [self primaryBHSScan:pWord forMatchType:matchType];
        else [self secondaryBHSScan:pWord andSecondaryWord:sWord withWordSpan:searchSpan];
        isSearchSuccessful = true;
    }
    else isSearchSuccessful = false;
    [labBHSSearchProgressLbl setStringValue:@"Single word search complete"];
    [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
    [self displayBHSResult];
}

- (void) primaryBHSScan: (NSString *) targetWord forMatchType: (NSInteger) matchType
{
    bool isAMatchFound, isExisting = false;
    NSInteger noOfBooks, idx, bdx, cdx, vdx, wdx, noOfChaps, noOfVerses, noOfWords, noOfStrongNos = 0;
    classBHSBook *currentBook;
    classBHSChapter *currentChapter;
    classBHSVerse *currentVerse;
    classBHSWord *currentWord;
    classBHSPrimaryResult *primaryResult, *prevSearchResult;

    noOfBooks = [globalVarsBHSSearch noOfBHSBooks];
    for (bdx = 0; bdx < noOfBooks; bdx++)
    {
        // Is the current book in the list to be searched?
        currentBook = nil;
        currentBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString: bdx]];
        if( currentBook == nil) continue;
        if (! [booksToInclude containsObject:[currentBook bookName]] ) continue;
        [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"Simple scan in process; scanning %@", [currentBook bookName]]];
        [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
        noOfChaps = [currentBook noOfChaptersInBook];
        for (cdx = 0; cdx < noOfChaps; cdx++)
        {
            currentChapter = [currentBook getChapterBySequence:cdx];
            noOfVerses = [currentChapter noOfVersesInChapter];
            for (vdx = 0; vdx < noOfVerses; vdx++)
            {
                currentVerse = [currentChapter getVerseBySequence:vdx];
                noOfWords = [currentVerse wordCount];
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    isAMatchFound = false;
                    currentWord = [currentVerse getWord:wdx];
                    noOfStrongNos = [currentWord noOfStrongRefs];
                    for (idx = 0; idx < noOfStrongNos; idx++)
                    {
                        isAMatchFound = [self isThereABHSMatch:currentWord matchType:matchType withStrongRefs:strongRefs andTargetWord:targetWord];
                        if (isAMatchFound) break;
                    }
                    if (isAMatchFound)
                    {
                        prevSearchResult = nil;
                        isExisting = false;
                        if( noOfMatchingBHSVerses > 0 )
                        {
                            prevSearchResult = [listOfBHSPrimaryResults objectForKey:[globalVarsBHSSearch convertIntegerToString: noOfMatchingBHSVerses - 1]];
                            if( prevSearchResult != nil)
                            {
                                if( ( bdx == [prevSearchResult bookId] ) && ( cdx == [prevSearchResult chapSeq] ) && ( vdx == [prevSearchResult verseSeq] ) )
                                {
                                    isExisting = true;
                                }
                            }
                        }
                        if (isExisting) primaryResult = prevSearchResult;
                        else
                        {
                            primaryResult = [[classBHSPrimaryResult alloc] init];
                            [primaryResult setBookId:bdx];
                            [primaryResult setChapSeq:cdx];
                            [primaryResult setVerseSeq:vdx];
                            [primaryResult setChapReference:[currentBook getChapterNoBySequence:cdx]];
                            [primaryResult setVerseReference:[currentChapter getVerseNoBySequence:vdx]];
                            [primaryResult setImpactedVerse:currentVerse];
                        }
                        [primaryResult addWordPosition:wdx];
                        if( [primaryResult noOfMatchingWords] == 1) [listOfBHSPrimaryResults setObject:primaryResult forKey:[globalVarsBHSSearch convertIntegerToString: noOfMatchingBHSVerses++]];
                    }
                }
            }
        }
    }
}

- (void) secondaryBHSScan: (NSString *) pWord andSecondaryWord: (NSString *) sWord withWordSpan: (NSInteger) searchSpan
{
    /*==========================================================================================================*
     *                                                                                                          *
     *                                         secondaryMTScan                                                  *
     *                                         ===============                                                  *
     *                                                                                                          *
     *  We are taking a completely different tack for the more complex search (a Primary and Secondary match    *
     *    within a given number of words of each other).                                                        *
     *                                                                                                          *
     *  In its simplest form, a verse may be of the form P ... S or S ... P - i.e. within the verse, there is a *
     *    single instance of each of the target words.                                                          *
     *                                                                                                          *
     *  Somewhat more complex is that this matching pair may occur across verse boundaries.  We have taken the  *
     *    tactical decision that such cross-verse matches will, at worst, span three verses.                    *
     *                                                                                                          *
     *  Somewhat more complex, is a variety of more complex matches - for example:                              *
     *                                                                                                          *
     *                P .. P ... S              or        S  .. S ... P                                         *
     *                P ... S ... P             or        S ... P ... S                                         *
     *                                                                                                          *
     *  In previous versions of the application we used the primary scan to identify P and then revisited each  *
     *    match of P to identify matching occurrences of S.  However, were the verse was of the form            *
     *                                                                                                          *
     *                                 P .... P ... S                                                           *
     *                                                                                                          *
     *  the first occurrence of the primary match sometimes masked the second, closer match and the proximate   *
     *    match was missed.                                                                                     *
     *                                                                                                          *
     *  Matching Tactic                                                                                         *
     *  ===============                                                                                         *
     *                                                                                                          *
     *  1. Load three contguous verses                                                                          *
     *  2. Scan the collection for the first occurrence of either P or S                                        *
     *  3. If found, continue for the next n words in search for S or P (where n = searchSpan)                  *
     *  4. Whether found or not, repeat 2. for the next occurrence                                              *
     *  5. If a match is found, inspect previous matches to see whether an identical match has already been     *
     *     found and, if it has, ignore the current match                                                       *
     *  6. If a previous match is not found, then store the result                                              *
     *  7. Once all words have been checked, remove the first of the three verses, shift the remaining two up   *
     *     one level and then add the next available verse.                                                     *
     *  8. Repeat steps 2 to 7                                                                                  *
     *                                                                                                          *
     *  Note, we do _not_ look for matches across book boundaries but we do across chapter boundaries.          *
     *                                                                                                          *
     *==========================================================================================================*/

    bool isAMatchFound;
    NSInteger idx, jdx, bdx, wdx, noOfWords, noOfScanUnits, noOfCurrentMatches = 0, lastChapSeq, lastVerseSeq;
    NSString *bookName;
    NSMutableArray *verseTriad;
    classBHSBook *currentSBook;
    classBHSChapter *currentSChapter;
    classBHSVerse *currentSVerse, *scannedSVerse;
    classBHSWord *currentSWord;
    classBHSScanUnit *currentScanUnit, *secondScanUnit;
    classBHSSearchMatches *currentSearchMatch, *pastSearchMatch;
    /*--------------------------------------------------------------------------------*
     *  scanSource:                                                                   *
     *  ----------                                                                    *
     *  Key:                                                                          *
     *  Value: an instance of the classMTScanUnit class                               *
     *                                                                                *
     *  currentMatches:                                                               *
     *  --------------                                                                *
     *  Key:                                                                          *
     *  Value: an instance of the classMTSearchMatches class                          *
     *--------------------------------------------------------------------------------*/
    NSMutableDictionary *scanSource, *currentMatches;

    [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"Scanning for matches of %@ with %@", pWord, sWord]];
    [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
    scanSource = [[NSMutableDictionary alloc] init];
    currentMatches = [[NSMutableDictionary alloc] init];
    verseTriad = [[NSMutableArray alloc] init];
    [allBHSMatches removeAllObjects];
    allBHSMatches = [[NSMutableDictionary alloc] init];
    noOfAllMatches = 0;
    // We are going to scan through all the books in the listbox to find matches
    for (bdx = 0; bdx < [globalVarsBHSSearch noOfBHSBooks]; bdx++)
    {
        currentSBook = nil;
        currentSBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString: bdx]];
        if( currentSBook == nil) continue;
        bookName = [currentSBook bookName];
        [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"Currently searching %@", bookName]];
        [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
        // Get the first three verses
        [verseTriad removeAllObjects];
        verseTriad = [[NSMutableArray alloc] init];
        currentSChapter = [currentSBook getChapterBySequence:0];
        currentSVerse = [currentSChapter getVerseBySequence:0];
        [verseTriad addObject:currentSVerse];
        currentSVerse = [currentSVerse nextVerse];
        [verseTriad addObject:currentSVerse];
        currentSVerse = [currentSVerse nextVerse];
        [verseTriad addObject:currentSVerse];
        lastChapSeq = [currentSBook noOfChaptersInBook];
        lastVerseSeq = [currentSChapter noOfVersesInChapter];
        // Now startScanning
        do
        {
            // First, put the target words into a structure we can work with
            noOfScanUnits = 0;
            [scanSource removeAllObjects];
            scanSource = [[NSMutableDictionary alloc] init];
            for (idx = 0; idx < 3; idx++)
            {
                scannedSVerse = [verseTriad objectAtIndex:idx];
                noOfWords = [scannedSVerse wordCount];
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    currentSWord = [scannedSVerse getWord:wdx];
                    currentScanUnit = [[classBHSScanUnit alloc] init];
                    [currentScanUnit setScanWord:currentSWord];
                    [currentScanUnit setChapterRef:[scannedSVerse chapRef]];
                    [currentScanUnit setVerseRef:[scannedSVerse verseRef]];
                    [currentScanUnit setChapterSeq:[scannedSVerse chapSeq]];
                    [currentScanUnit setVerseSeq:[scannedSVerse verseSeq]];
                    [currentScanUnit setWordSeq:wdx];
                    [scanSource setObject:currentScanUnit forKey:[globalVarsBHSSearch convertIntegerToString: noOfScanUnits++]];
                }
            }
            // Now scan through this set of words
            noOfCurrentMatches = 0;
            [currentMatches removeAllObjects];
            currentMatches = [[NSMutableDictionary alloc] init];
            for ( idx = 0; idx < noOfScanUnits; idx++)
            {
                currentScanUnit = nil;
                currentScanUnit = [scanSource objectForKey:[globalVarsBHSSearch convertIntegerToString:idx]];
                if( currentScanUnit == nil) continue;
                isAMatchFound = [self  isThereABHSMatch:[currentScanUnit scanWord] matchType:matchType withStrongRefs:strongRefs andTargetWord:pWord];
                if (isAMatchFound)
                {
                    // Look for an occurrence of the secondary within searchSpan words
                    for( jdx = 1; jdx <= searchSpan; jdx++)
                    {
                        if (idx + jdx >= noOfScanUnits) break;
                        secondScanUnit = nil;
                        secondScanUnit = [scanSource objectForKey:[globalVarsBHSSearch convertIntegerToString:idx + jdx]];
                        if( secondScanUnit == nil) continue;
                        isAMatchFound = [self isThereABHSMatch:[secondScanUnit scanWord] matchType:matchType withStrongRefs:SecondStrongRefs andTargetWord:sWord];
                        if( isAMatchFound)
                        {
                            currentSearchMatch = [[classBHSSearchMatches alloc] init];
                            [currentSearchMatch setPrimaryScanWord:[currentScanUnit scanWord]];
                            [currentSearchMatch setBookId:bdx];
                            [currentSearchMatch setPrimaryChapterRef:[currentScanUnit chapterRef]];
                            [currentSearchMatch setPrimaryVerseRef:[currentScanUnit verseRef]];
                            [currentSearchMatch setPrimaryChapterSeq:[currentScanUnit chapterSeq]];
                            [currentSearchMatch setPrimaryVerseSeq:[currentScanUnit verseSeq]];
                            [currentSearchMatch setPrimaryWordSeq:[currentScanUnit wordSeq]];
                            [currentSearchMatch setSecondaryScanWord:[secondScanUnit scanWord]];
                            [currentSearchMatch setSecondaryChapterRef:[secondScanUnit chapterRef]];
                            [currentSearchMatch setSecondaryVerseRef:[secondScanUnit verseRef]];
                            [currentSearchMatch setSecondaryChapterSeq:[secondScanUnit chapterSeq]];
                            [currentSearchMatch setSecondaryVerseSeq:[secondScanUnit verseSeq]];
                            [currentSearchMatch setSecondaryWordSeq:[secondScanUnit wordSeq]];
                            [currentMatches setObject:currentSearchMatch forKey:[globalVarsBHSSearch convertIntegerToString:noOfCurrentMatches++]];
                        }
                    }
                }
                else
                {
                    // Now look for a secondary match
                    isAMatchFound = [self isThereABHSMatch:[currentScanUnit scanWord] matchType:matchType withStrongRefs:SecondStrongRefs andTargetWord:sWord];
                    if (isAMatchFound)
                    {
                        // Look for an occurrence of the primary within searchSpan words
                        for (jdx = 1; jdx <= searchSpan; jdx++)
                        {
                            if (idx + jdx >= noOfScanUnits) break;
                            secondScanUnit = nil;
                            secondScanUnit = [scanSource objectForKey:[globalVarsBHSSearch convertIntegerToString:idx + jdx]];
                            if( secondScanUnit == nil) continue;
                            isAMatchFound = [self isThereABHSMatch:[secondScanUnit scanWord] matchType:matchType withStrongRefs:strongRefs andTargetWord:pWord];
                            if (isAMatchFound)
                            {
                                currentSearchMatch = [[classBHSSearchMatches alloc] init];
                                [currentSearchMatch setPrimaryScanWord:[secondScanUnit scanWord]];
                                [currentSearchMatch setBookId:bdx];
                                [currentSearchMatch setPrimaryChapterRef:[secondScanUnit chapterRef]];
                                [currentSearchMatch setPrimaryVerseRef:[secondScanUnit verseRef]];
                                [currentSearchMatch setPrimaryChapterSeq:[secondScanUnit chapterSeq]];
                                [currentSearchMatch setPrimaryVerseSeq:[secondScanUnit verseSeq]];
                                [currentSearchMatch setPrimaryWordSeq:[secondScanUnit wordSeq]];
                                [currentSearchMatch setSecondaryScanWord:[currentScanUnit scanWord]];
                                [currentSearchMatch setSecondaryChapterRef:[currentScanUnit chapterRef]];
                                [currentSearchMatch setSecondaryVerseRef:[currentScanUnit verseRef]];
                                [currentSearchMatch setSecondaryChapterSeq:[currentScanUnit chapterSeq]];
                                [currentSearchMatch setSecondaryVerseSeq:[currentScanUnit verseSeq]];
                                [currentSearchMatch setSecondaryWordSeq:[currentScanUnit wordSeq]];
                                [currentMatches setObject:currentSearchMatch forKey:[globalVarsBHSSearch convertIntegerToString:noOfCurrentMatches++]];
                            }
                        }
                    }
                }
            }
            // We now have _potential matches but they may already have been identified
            for( idx = 0; idx < noOfAllMatches; idx++)
            {
                pastSearchMatch = nil;
                pastSearchMatch = [allBHSMatches objectForKey:[globalVarsBHSSearch convertIntegerToString:idx]];
                for( jdx = 0; jdx < noOfCurrentMatches; jdx++)
                {
                    currentSearchMatch = nil;
                    currentSearchMatch = [currentMatches objectForKey:[globalVarsBHSSearch convertIntegerToString:jdx]];
                    if (([currentSearchMatch bookId] == [pastSearchMatch bookId]) &&
                       ([currentSearchMatch primaryChapterSeq] == [pastSearchMatch primaryChapterSeq] ) &&
                       ([currentSearchMatch primaryVerseSeq] == [pastSearchMatch primaryVerseSeq]) &&
                       ([currentSearchMatch secondaryChapterSeq] == [pastSearchMatch secondaryChapterSeq]) &&
                       ([currentSearchMatch secondaryVerseSeq] == [pastSearchMatch secondaryVerseSeq])) [currentSearchMatch setIsValid:false];
                }
            }
            // Now we've checked everything, add new valid results to the list of matches
            for( jdx = 0; jdx < noOfCurrentMatches; jdx++)
            {
                currentSearchMatch = nil;
                currentSearchMatch = [currentMatches objectForKey:[globalVarsBHSSearch convertIntegerToString:jdx]];
                if ([currentSearchMatch isValid]) [allBHSMatches setObject:currentSearchMatch forKey:[globalVarsBHSSearch convertIntegerToString:noOfAllMatches++]];
            }
            [verseTriad replaceObjectAtIndex:0 withObject:[verseTriad objectAtIndex:1]];
            [verseTriad replaceObjectAtIndex:1 withObject:[verseTriad objectAtIndex:2]];
            currentSVerse = [currentSVerse nextVerse];
            [verseTriad replaceObjectAtIndex:2 withObject:currentSVerse];
        } while ([currentSVerse nextVerse] != nil);
    }
}

- (bool) isThereABHSMatch: (classBHSWord *) currentWord matchType: (NSInteger) matchType withStrongRefs: (NSArray *) strongRefs andTargetWord: (NSString *) targetWord
{
    bool isFound = false;
    NSInteger tempStrongNo, idx, noOfStrongNos;
    NSString *candidateWord;

    switch (matchType)
    {
        case 1:
            noOfStrongNos = [currentWord noOfStrongRefs];
            for (idx = 0; idx < noOfStrongNos; idx++)
            {
                tempStrongNo = [currentWord getStrongRefBySeq:idx];
                if ([strongRefs containsObject:[globalVarsBHSSearch convertIntegerToString:tempStrongNo]] )
                {
                    isFound = true;
                    break;
                }
            }
            break;
        case 2:
            candidateWord = [currentWord unaccentedWord];
            if ( [candidateWord compare:targetWord] == NSOrderedSame) isFound = true;
            break;
        case 3:
            candidateWord = [currentWord bareWord];
            if ( [candidateWord compare:[self removeNonConsonents: targetWord]] == NSOrderedSame) isFound = true;
            break;
    }
    return isFound;
}

- (NSString *) removeAccentsAndNonHebrew: (NSString *) sourceWord
{
    /*========================================================================================*
     *                                                                                        *
     *                               removeAccentsAndNonHebrew                                *
     *                               =========================                                *
     *                                                                                        *
     *  This method apparently replicates removeAccents in classHebLexicon.  However, there   *
     *    it retains ASCII characters and, specifically, linefeeds.  Since I can't be sure    *
     *    that removing these elements won't create problems elsewhere, I've created a        *
     *    pseudo-duplicate.  (It demonstrates how code grows: we add, as needed, but are wary *
     *    of deleting existing code.)                                                         *
     *                                                                                        *
     *  Purpose: to remove all except                                                         *
     *           a) core Hebrew characters                                                    *
     *           b) vowel pointing                                                            *
     *           c) sin/shin points                                                           *
     *           d) dagesh (forte and line)                                                   *
     *                                                                                        *
     *  Parameter:                                                                            *
     *  =========                                                                             *
     *                                                                                        *
     *  sourceWord   may be a word, sentence or entire verse, so can includes spaces.         *
     *                                                                                        *
     *========================================================================================*/

    NSInteger idx, wordLength;
    NSMutableString *resultingWord;

    resultingWord = [[NSMutableString alloc] initWithString:@""];
    wordLength = [sourceWord length];
    for (idx = 0; idx < wordLength; idx++)
    {
        // Is the character a standard Hebrew consonant?
        if (((NSInteger)[sourceWord characterAtIndex:idx] >= 0x5d0) && ((NSInteger)[sourceWord characterAtIndex:idx] <= 0x5ea))
        {
            [resultingWord appendString: [sourceWord substringWithRange:NSMakeRange(idx, 1)]];
            continue;
        }
        // Is the character a vowel or acceptable pointing character?
        if (((NSInteger)[sourceWord characterAtIndex:idx] >= 0x5b0) && ((NSInteger)[sourceWord characterAtIndex:idx] <= 0x5bc))
        {
            [resultingWord appendString: [sourceWord substringWithRange:NSMakeRange(idx, 1)]];
            continue;
        }
        // Is the character a sin/shin dot, end of verse Sof Pasuq or mark dot ?
        if (((NSInteger)[sourceWord characterAtIndex: idx] >= 0x5c1) && ((NSInteger)[sourceWord characterAtIndex: idx] <= 0x5c5))
        {
            [resultingWord appendString: [sourceWord substringWithRange:NSMakeRange(idx, 1)]];
            continue;
        }
    }
    return resultingWord;
}

- (NSString *) removeNonConsonents: (NSString *) sourceWord
{
    /*==============================================================================================*
     *                                                                                              *
     *                                       removeNonConsonents                                    *
     *                                       ===================                                    *
     *                                                                                              *
     *  Purpose: to remove all except core Hebrew characters                                        *
     *                                                                                              *
     *  This will remove:                                                                           *
     *           a) vowel pointing                                                                  *
     *           b) sin/shin points                                                                 *
     *           c) dagesh (forte and line)                                                         *
     *                                                                                              *
     *  Parameter:                                                                                  *
     *  =========                                                                                   *
     *                                                                                              *
     *  sourceWord   may be a word, sentence or entire verse, so can includes spaces.               *
     *                                                                                              *
     *==============================================================================================*/

    NSInteger idx, wordLength;
    NSMutableString *resultingWord;

    resultingWord = [[NSMutableString alloc] initWithString:@""];
    wordLength = [sourceWord length];
    for (idx = 0; idx < wordLength; idx++)
    {
        // Is the character a standard Hebrew consonant?
        if (([sourceWord characterAtIndex:idx] >= 0x5d0) && ([sourceWord characterAtIndex: idx] <= 0x5ea))
        {
            [resultingWord appendString:[sourceWord substringWithRange:NSMakeRange(idx, 1)]];
            continue;
        }
        // Is the character a low order ASCII character, including space and non-break space
        if (([sourceWord characterAtIndex:idx] >= 0x0020) & ([sourceWord characterAtIndex:idx] <= 0x00a0))
        {
            [resultingWord appendString:[sourceWord substringWithRange:NSMakeRange(idx, 1)]];
            continue;
        }
        // Is the character a carriage return?
        if ([sourceWord characterAtIndex: idx] == '\n')
        {
            [resultingWord appendString: @"\n"];
            continue;
        }
    }
    return resultingWord;
}

- (void) initialBHSMatchProcessing: (NSInteger) pBook
                    primarychapter: (NSString *) pChap
                      primaryVerse: (NSString *) pVerse
               primaryWordSequence: (NSInteger) pSeq
                       primaryWord: (NSString *) pWord
                     secondaryBook: (NSInteger) sBook
                  secondaryChapter: (NSString *) sChap
                    secondaryVerse: (NSString *) sVerse
             secondaryWordSequence: (NSInteger) sSeq
                     secondaryWord: (NSString *) sWord
{
    NSInteger idx, noOfStrongNos = 0;
    NSMutableArray *tempStrongsRefs, *temp2ndStrongsRefs;
//    StatusStrip targetToolStrip;
    classWordToStrong *currentConversion;
    classSearchVerify *verifyResult;

    tempStrongsRefs = nil;
    temp2ndStrongsRefs = nil;
    isSearchSuccessful = false;
    noOfMatchingBHSVerses = 0;
    [listOfBHSPrimaryResults removeAllObjects];
    listOfBHSPrimaryResults = [[NSMutableDictionary alloc] init];
    [labBHSSearchProgressLbl setStringValue:@"Analysing the given primary word"];
    [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
    // 1  Let's find all primary matches first
    // 1a If the primary word is not set, then we need to find an example
    if (pBook >= 0)
    {
        // Okay, we have a word.  But does it match?
        [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"%@ found; checking validity", pWord]];
        [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
        verifyResult = [self bhsVerifyWord:pBook chapterRef:pChap verseRef:pVerse wordSequence:pSeq wordToVerify:pWord matchType:matchType];
        isWordGiven = [verifyResult isWordGiven];
        if (isWordGiven) strongRefs = [verifyResult selectedStrongList];
    }
    // No, it didn't match
    if (!isWordGiven)
    {
        // We need to find the given word; it was entered manually
        currentConversion = nil;
        currentConversion = [[searchBHSText listOfStrongConversions] objectForKey:pWord];
        if (currentConversion != nil)
        {
            noOfStrongNos = [currentConversion noOfStrongRefs];
            for (idx = 0; idx < noOfStrongNos; idx++)
            {
                if (tempStrongsRefs == nil) tempStrongsRefs = [[NSMutableArray alloc] init];
                [tempStrongsRefs addObject:[globalVarsBHSSearch convertIntegerToString:[currentConversion getStrongRefByIndex:idx]]];
            }
            isWordGiven = true;
            strongRefs = [[NSArray alloc] initWithArray:tempStrongsRefs];
        }
    }
    // Now we have something
    if (isWordGiven)
    {
        // Step 2: if it is a secondary search, we need to repeat the process
        //         Note: we must strictly partition the responses for primary and secondary words
        if (currentSearchType == 2)
        {
            [labBHSSearchProgressLbl setStringValue:@"Analysing the given secondary word"];
            [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
            if (sBook >= 0)
            {
                // Okay, we have a word.  But does it match?
                [labBHSSearchProgressLbl setStringValue:[[NSString alloc] initWithFormat:@"%@ found; checking validity", sWord]];
                [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
                verifyResult = [self bhsVerifyWord:sBook chapterRef:sChap verseRef:sVerse wordSequence:sSeq wordToVerify:sWord matchType:matchType];
                if( verifyResult != nil)
                {
                    isSWordGiven = [verifyResult isWordGiven];
                    if (isSWordGiven) SecondStrongRefs = [verifyResult selectedStrongList];
                }
            }
            // No, it didn't match
            if (!isSWordGiven)
            {
                // We need to find the given word; it was entered manually
                currentConversion = nil;
                currentConversion = [[searchBHSText listOfStrongConversions] objectForKey:sWord];
                if (currentConversion != nil)
                {
                    noOfStrongNos = [currentConversion noOfStrongRefs];
                    for (idx = 0; idx < noOfStrongNos; idx++)
                    {
                        if (temp2ndStrongsRefs == nil) temp2ndStrongsRefs = [[NSMutableArray alloc] init];
                        [temp2ndStrongsRefs addObject:[[NSString alloc] initWithFormat:@"%ld",[currentConversion getStrongRefByIndex:idx]]];
                    }
                    isSWordGiven = true;
                    SecondStrongRefs = [[NSArray alloc] initWithArray:temp2ndStrongsRefs];
                }
            }
        }
    }
}

- (classSearchVerify *) bhsVerifyWord: (NSInteger) bookNo
                           chapterRef: (NSString *) chapRef
                             verseRef: (NSString *) verseRef
                         wordSequence: (NSInteger) wordSeq
                         wordToVerify: (NSString *) wordToVerify
                            matchType: (NSInteger) matchType
{
    bool isWordGiven = false;
    NSString *unaccented1, *unaccented2;
    NSArray *currentStrongList;
    classBHSBook *currentBook;
    classBHSChapter *currentChapter;
    classBHSVerse *currentVerse;
    classBHSWord *currentWord;
    classSearchVerify *newVerification;

    currentBook = nil;
    currentBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString:bookNo]];
    if( currentBook == nil) return nil;
    currentChapter = [currentBook getChapterByChapterNo:chapRef];
    currentVerse = [currentChapter getVerseByVerseNo:verseRef];
    currentWord = [currentVerse getWord:wordSeq];
    unaccented1 = [[NSString alloc] initWithString:[currentWord unaccentedWord]];
    unaccented2 = [[NSString alloc] initWithString:[self removeAccentsAndNonHebrew:wordToVerify]];
    if (matchType < 3)
    {
        if( [unaccented1 compare:unaccented2] == NSOrderedSame)
//            if( [[currentWord unaccentedWord] compare:[searchHebrewLexicon removeAccents:wordToVerify]] == NSOrderedSame)
        {
            isWordGiven = true;
            currentStrongList = [[NSArray alloc] initWithArray:[self getStrongRefs:currentWord]];
        }
    }
    else
    {
        // If we _didn't_ match, try it without vowels
        if( [[currentWord bareWord] compare:[self removeNonConsonents:wordToVerify]] == NSOrderedSame)
        {
            isWordGiven = true;
            currentStrongList = [[NSArray alloc] initWithArray:[self getStrongRefs:currentWord]];
        }
    }
    newVerification = [[classSearchVerify alloc] init];
    [newVerification setIsWordGiven:isWordGiven];
    [newVerification setSelectedStrongList:[[NSArray alloc] initWithArray:currentStrongList]];
    return newVerification;
}

- (NSArray *) getStrongRefs: (classBHSWord *) currentWord
{
    NSInteger idx, noOfStrongNos;
    NSMutableArray *tempList;

    tempList = [[NSMutableArray alloc] init];
    noOfStrongNos = [currentWord noOfStrongRefs];
    for (idx = 0; idx < noOfStrongNos; idx++)
    {
        [tempList addObject:[globalVarsBHSSearch convertIntegerToString:[currentWord getStrongRefBySeq:idx]]];
    }
    return [[NSArray alloc] initWithArray:tempList];
}

- (void) displayBHSResult
{
    [labBHSSearchProgressLbl setStringValue:@"Starting display of results"];
    [bhsSearchLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];
    bhsResultsTextView = [globalVarsBHSSearch txtSearchResults];
    if (isSearchSuccessful)
    {
        [[bhsResultsTextView textStorage] deleteCharactersInRange:NSMakeRange(0, [[bhsResultsTextView textStorage] length])];
        bhsDisplayAlignment = 2;
        if (currentSearchType == 1) [self displayPrimary];
        else [self displaySecondary];
    }
}

- (void) displayPrimary
{
    bhsBackgroundThread = [[NSThread alloc] initWithTarget:self selector:@selector(collatePrimaryDisplayResults) object:nil];
    if( bhsSearchResults == nil) bhsSearchResults = [[NSMutableDictionary alloc] init];
    [bhsSearchResults removeAllObjects];
    bhsResultsTextView = [globalVarsBHSSearch txtSearchResults];
    bhsLatestResultCount = -1;
    bhsRunningResultCount = -1;
    [bhsBackgroundThread start];
    bhsDisplayTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(performPrimaryDisplay:) userInfo:nil repeats:YES];
}

- (void) performPrimaryDisplay: (id) sender
{
    NSTextStorage *textStorage;

    textStorage = [bhsResultsTextView textStorage];
    [labBHSSearchProgressLbl setStringValue:@"Displaying results"];
    if( bhsLatestResultCount > bhsRunningResultCount)
    {
        for( ++bhsRunningResultCount; bhsRunningResultCount <= bhsLatestResultCount; bhsRunningResultCount++)
        {
            [labBHSSearchProgressLbl setStringValue:bhsProgressMessage];
            [textStorage appendAttributedString:[bhsSearchResults objectForKey:[globalVarsBHSSearch convertIntegerToString:bhsRunningResultCount]]];
        }
    }
    if( [bhsProgressMessage compare:@"Search Results complete"] == NSOrderedSame)
    {
        [bhsDisplayTimer invalidate];
    }
}

- (void) collatePrimaryDisplayResults
{
    /*====================================================================================================*
     *                                                                                                    *
     *                                    collatePrimaryDisplayResults                                    *
     *                                    ============================                                    *
     *                                                                                                    *
     *  This runs as a bacground thread.  In order to enable this, each search result is stored as an     *
     *    attributed string in a dictionary, which can be accessed by the main thread.  The main thread   *
     *    will inspect this dictionary regularly and display any new results.                             *
     *                                                                                                    *
     *====================================================================================================*/
    // effectively character constants
    NSString *zeroWidthSpace, *zeroWidthNonJoiner, *noBreakSpace, *ideographicSpace;

    NSInteger idx, noOfMatches, wdx, noOfWords = 0, noOfLines;
    NSString *postfix, *theAffix, *workingText;
    NSMutableString *interimText;
    NSMutableAttributedString *singleResult;
    NSArray *listOfWordPositions;
    classBHSBook *currentBook;
    classBHSVerse *currentVerse;
    classBHSWord *currentWord;
    classBHSPrimaryResult *currentSearchResult;
    classDisplayUtilities *displayUtility;

    displayUtility = [[classDisplayUtilities alloc] init:globalVarsBHSSearch];
    zeroWidthSpace = [[NSString alloc] initWithFormat:@"%C", 0x200b];
    zeroWidthNonJoiner = [[NSString alloc] initWithFormat:@"%C", 0x200d];
    noBreakSpace = [[NSString alloc] initWithFormat:@"%C", 0x00a0];
    ideographicSpace = [[NSString alloc] initWithFormat:@"%C", 0x3000];
    noOfMatches = noOfMatchingBHSVerses;
    noOfLines = 0;
    for (idx = 0; idx < noOfMatches; idx++)
    {
        singleResult = [[NSMutableAttributedString alloc] initWithString:@""];
        if( idx > 0 )
        {
            [singleResult appendAttributedString:[displayUtility addAttributedText:@"\n\n" offsetCode:0 fontId:10 alignment:0 withAdjustmentFor:bhsResultsTextView]];
        }
        currentSearchResult = nil;
        currentSearchResult = [listOfBHSPrimaryResults objectForKey:[globalVarsBHSSearch convertIntegerToString: idx]];
        currentBook = nil;
        currentBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString:[currentSearchResult bookId]]];
        currentVerse = [currentSearchResult impactedVerse];
            // Where a book name contains spaces, we don't want this split wierdly because of right-to-left text, so we use "\u3000" as a space
        interimText = [[NSMutableString alloc] initWithString:[currentBook bookName]];
        [interimText replaceOccurrencesOfString:@" " withString:ideographicSpace options:NSLiteralSearch range:NSMakeRange(0, [interimText length])];
        workingText = [[NSString alloc] initWithFormat:@"%@%@%@.%@", interimText, noBreakSpace, [currentSearchResult chapReference], [currentSearchResult verseReference]];
        bhsProgressMessage = [[NSString alloc] initWithFormat:@"Displaying: %@", workingText];
        [singleResult appendAttributedString:[displayUtility addAttributedText:workingText offsetCode:0 fontId:9 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        [singleResult appendAttributedString:[displayUtility addAttributedText:@": " offsetCode:0 fontId:9 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        noOfWords = [currentVerse wordCount];
        listOfWordPositions = [[NSArray alloc] initWithArray:[[currentSearchResult matchingWordPositions] allValues]];
        for (wdx = 0; wdx < noOfWords; wdx++)
        {
            currentWord = [currentVerse getWord:wdx];
            [singleResult appendAttributedString:[displayUtility addAttributedText:zeroWidthSpace offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
            if ( [listOfWordPositions doesContain:[globalVarsBHSSearch convertIntegerToString:wdx]])
            {
                [singleResult appendAttributedString:[displayUtility addAttributedText:[currentWord actualWord] offsetCode:0 fontId:11 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
            }
            else
            {
                [singleResult appendAttributedString:[displayUtility addAttributedText:[currentWord actualWord] offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
            }
            if( ( ! [currentWord isPrefix]) && ( [[currentWord affix] compare:@""] != NSOrderedSame ) ) postfix = @" ";
            else postfix = @"";
            if( [[currentWord affix] length] > 0 ) theAffix = [[NSString alloc] initWithString:[currentWord affix]];
            else theAffix = @"";
            [singleResult appendAttributedString:[displayUtility addAttributedText:[[NSString alloc] initWithFormat:@"%@%@", theAffix, postfix] offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        }
        [bhsSearchResults setObject:singleResult forKey:[globalVarsBHSSearch convertIntegerToString:idx]];
        bhsLatestResultCount = idx;
    }
    bhsProgressMessage = @"Search Results complete";
}

- (void) displaySecondary
{
    bhsBackgroundThread = [[NSThread alloc] initWithTarget:self selector:@selector(collateSecondaryDisplayResults) object:nil];
    if( bhsSearchResults == nil) bhsSearchResults = [[NSMutableDictionary alloc] init];
    [bhsSearchResults removeAllObjects];
    bhsResultsTextView = [globalVarsBHSSearch txtSearchResults];
    bhsLatestResultCount = -1;
    bhsRunningResultCount = -1;
    [bhsBackgroundThread start];
    bhsDisplayTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self selector:@selector(performSecondaryDisplay:) userInfo:nil repeats:YES];
}

- (void) performSecondaryDisplay: (id) sender
{
    NSTextStorage *textStorage;

    textStorage = [bhsResultsTextView textStorage];
    [labBHSSearchProgressLbl setStringValue:@"Displaying results"];
    if( bhsLatestResultCount > bhsRunningResultCount)
    {
        for( ++bhsRunningResultCount; bhsRunningResultCount <= bhsLatestResultCount; bhsRunningResultCount++)
        {
            [labBHSSearchProgressLbl setStringValue:bhsProgressMessage];
            [textStorage appendAttributedString:[bhsSearchResults objectForKey:[globalVarsBHSSearch convertIntegerToString:bhsRunningResultCount]]];
        }
    }
    if( [bhsProgressMessage compare:@"Search Results complete"] == NSOrderedSame)
    {
        [bhsDisplayTimer invalidate];
    }
}

- (void) collateSecondaryDisplayResults
{
    /*========================================================================================================================*
     *                                                                                                                        *
     *                                                 displaySecondary                                                       *
     *                                                 ================                                                       *
     *                                                                                                                        *
     *  Manage the display of verses satisfying a complex search, consisting of two words within a set number of words of     *
     *    each other.                                                                                                         *
     *                                                                                                                        *
     *  The starting point of this process is a list of class instances, allMatches, which each list a primary and secondary  *
     *    word that satisfy the search criteria.  Note that:                                                                  *
     *                                                                                                                        *
     *    a) the list will be in strict sequence;                                                                             *
     *    b) the determining word, however, may be either a primary or secondary match;                                       *
     *    c) the matching word (either primary or secondary, that comes second) may be within the same verse or the following *
     *         verse or the one after;                                                                                        *
     *    d) additional matches may occur after the first element of the previous match but before the second;                *
     *    e) specifically, we may get:                                                                                        *
     *           match n: primary is chapter 6.4, word 5 while secondary is 6.5, word 2                                       *
     *           match n+1: primary is chapter 6.4, word 7 while secondary is also 6.5, word 2                                *
     *                                                                                                                        *
     *  Processing:                                                                                                           *
     *  ==========                                                                                                            *
     *                                                                                                                        *
     *  In order to convert the individual matches into information that can be displayed sequentially, we will first convert *
     *    each match to a unique reference value.  To do this, we perform the calculation:                                    *
     *                                                                                                                        *
     *                        referenceValue = 1 000 000 * bookId + 1000 * chapterSeq + verseSeq                              *
     *                                                                                                                        *
     *    This will than be used as a key for a verse reference.  If the source record has the second match in a different    *
     *    verse to the first, then the stored verse information will also be marked as "contiguous" with the next.            *
     *                                                                                                                        *
     *========================================================================================================================*/

    // effectively character constants
    NSString *zeroWidthSpace, *zeroWidthNonJoiner, *noBreakSpace, *ideographicSpace;
    NSMutableAttributedString *singleResult;
    NSInteger idx, bdx, primaryChap, primaryVerse, secondaryChap, secondaryVerse, wdx, noOfWords = 0,
            index = 0, typeCode;
    NSString *postfix, *theAffix, *referenceText, *primaryReferenceValue, *secondaryReferenceValue, *dictionaryValue, *dictionaryKey;
    NSMutableString *interimText;
    NSMutableDictionary *versesMatched;
    NSArray *unorderedKeys, *orderedKeys;
    classBHSBook *currentBook;
    classBHSChapter *currentChapter;
    classBHSVerse *currentVerse;
    classBHSWord *currentWord;
    classBHSSearchVerse *primarySearchVerse, *secondarySearchVerse;
    classBHSSearchMatches *currentMatch;
    classDisplayUtilities *displayUtility;

    versesMatched = [[NSMutableDictionary alloc] init];
    zeroWidthSpace = [[NSString alloc] initWithFormat:@"%C", 0x200b];
    zeroWidthNonJoiner = [[NSString alloc] initWithFormat:@"%C", 0x200d];
    noBreakSpace = [[NSString alloc] initWithFormat:@"%C", 0x00a0];
    ideographicSpace = [[NSString alloc] initWithFormat:@"%C", 0x3000];
    displayUtility = [[classDisplayUtilities alloc] init:globalVarsBHSSearch];

    bhsProgressMessage = @"Displaying results";
    // Step 1: Arrange the list of all matches further
    for (idx = 0; idx < noOfAllMatches; idx++)
    {
        currentMatch = nil;
        currentMatch = [allBHSMatches objectForKey:[globalVarsBHSSearch convertIntegerToString:idx]];
        bdx = [currentMatch bookId];
        currentBook = nil;
        currentBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString:bdx]];
        primaryChap = [currentMatch primaryChapterSeq];
        primaryVerse = [currentMatch primaryVerseSeq];
        secondaryChap = [currentMatch secondaryChapterSeq];
        secondaryVerse = [currentMatch secondaryVerseSeq];
        primaryReferenceValue = [self createReferenceValue:bdx chapter:primaryChap verse:primaryVerse];
        secondaryReferenceValue = [self createReferenceValue:bdx chapter:secondaryChap verse:secondaryVerse];
        primarySearchVerse = nil;
        primarySearchVerse = [versesMatched objectForKey:primaryReferenceValue];
        if (primarySearchVerse == nil)
        {
            primarySearchVerse = [[classBHSSearchVerse alloc] init:globalVarsBHSSearch];
            [primarySearchVerse setBookId:bdx];
            [primarySearchVerse setChapterNumber:primaryChap];
            [primarySearchVerse setVerseNumber:primaryVerse];
            [primarySearchVerse setChapterReference:[currentMatch primaryChapterRef]];
            [primarySearchVerse setVerseReference:[currentMatch primaryVerseRef]];
            currentChapter = [currentBook getChapterBySequence:primaryChap];
            [primarySearchVerse setImpactedVerse:[currentChapter getVerseBySequence:primaryVerse]];
            [versesMatched setObject:primarySearchVerse forKey:primaryReferenceValue];
        }
        [primarySearchVerse addWordPosition:[currentMatch primaryWordSeq] forWordType:1];
        secondarySearchVerse = nil;
        secondarySearchVerse = [versesMatched objectForKey:secondaryReferenceValue];
        if (secondarySearchVerse == nil)
        {
            secondarySearchVerse = [[classBHSSearchVerse alloc] init:globalVarsBHSSearch];
            [secondarySearchVerse setBookId:bdx];
            [secondarySearchVerse setChapterNumber:secondaryChap];
            [secondarySearchVerse setVerseNumber:secondaryVerse];
            [secondarySearchVerse setChapterReference:[currentMatch secondaryChapterRef]];
            [secondarySearchVerse setVerseReference:[currentMatch secondaryVerseRef]];
            currentChapter = [currentBook getChapterBySequence:secondaryChap];
            [secondarySearchVerse setImpactedVerse:[currentChapter getVerseBySequence:secondaryVerse]];
            [versesMatched setObject:secondarySearchVerse forKey:secondaryReferenceValue];
        }
        [secondarySearchVerse addWordPosition:[currentMatch secondaryWordSeq] forWordType:2];
        if ([primaryReferenceValue integerValue] > [secondaryReferenceValue integerValue]) [secondarySearchVerse setIsFollowed:true];
        else
        {
            if ([secondaryReferenceValue integerValue] > [primaryReferenceValue integerValue]) [primarySearchVerse setIsFollowed:true];
        }
    }
    // We now have information on all relevant matches
    unorderedKeys = [[NSArray alloc] initWithArray:[versesMatched allKeys]];
    orderedKeys = [[NSArray alloc] initWithArray:[unorderedKeys sortedArrayUsingSelector:@selector(compare:)]];
    idx = -1;
    for( dictionaryKey in orderedKeys)
    {
        ++idx;
        singleResult = [[NSMutableAttributedString alloc] initWithString:@""];
        primarySearchVerse = [versesMatched objectForKey:dictionaryKey];
        currentVerse = [primarySearchVerse impactedVerse];
        currentBook = [[globalVarsBHSSearch bhsBookList] objectForKey:[globalVarsBHSSearch convertIntegerToString:[primarySearchVerse bookId]]];
        interimText = [[NSMutableString alloc] initWithString:[currentBook bookName]];
        [interimText replaceOccurrencesOfString:@" " withString:ideographicSpace options:NSLiteralSearch range:NSMakeRange(0, [interimText length])];
        referenceText = [[NSString alloc] initWithFormat:@"%@%@%@.%@", interimText, noBreakSpace, [primarySearchVerse chapterReference], [primarySearchVerse verseReference]];
        bhsProgressMessage = [[NSString alloc] initWithFormat:@"Displaying: %@", referenceText];
        [singleResult appendAttributedString:[displayUtility addAttributedText:referenceText offsetCode:0 fontId:9 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        [singleResult appendAttributedString:[displayUtility addAttributedText:@": " offsetCode:0 fontId:9 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];

        noOfWords = [currentVerse  wordCount];
        index = 0;
        for (wdx = 0; wdx < noOfWords; wdx++)
        {
            /*---------------------------------------------------------------------------------------------------------*
            *                                                                                                         *
            *  A reminder:                                                                                            *
            *                                                                                                         *
            *  primarySearchVerse.matchingWordPositions is a dictionary keyed on a sequential integer.  Each entry    *
            *    gives the word sequence position of a word that matches one of the search criteria, whether primary  *
            *    or secondary.                                                                                        *
            *                                                                                                         *
            *  primarySearchVerse.matchingWordType also has an entry for the same integer sequence but the related    *
            *    value tells us whether the match is primary (1) or secondary (2).                                    *
            *                                                                                                         *
            *  So, as we step through the whole verse, we must check whether wdx matches one of the values for        *
            *    matchingWordPosition.  If it does, we then need to get the type code, to tell whether it is primary  *
            *    or secondary, and process it accordingly.                                                            *
            *                                                                                                         *
            *  Note that the sequence number (Key) for both dictionaries starts with zero.                            *
            *                                                                                                         *
            *---------------------------------------------------------------------------------------------------------*/
            currentWord = [currentVerse getWord:wdx];
            [singleResult appendAttributedString:[displayUtility addAttributedText:zeroWidthSpace offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
            dictionaryValue = nil;
            {
                typeCode = 0;
                for( dictionaryKey in [primarySearchVerse matchingWordPositions])
                {
                    dictionaryValue = [[primarySearchVerse matchingWordPositions] objectForKey:dictionaryKey];
                    if( [dictionaryValue integerValue] == wdx)
                    {
                        typeCode = [[[primarySearchVerse matchingWordType] objectForKey:dictionaryKey] integerValue];
                        break;
                    }
                }
                switch( typeCode )
                {
                    case 0:
                        [singleResult appendAttributedString:[displayUtility addAttributedText:[currentWord actualWord] offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
                        break;
                    case 1:
                        [singleResult appendAttributedString:[displayUtility addAttributedText:[currentWord actualWord] offsetCode:0 fontId:11 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
                        break;
                    case 2:
                        [singleResult appendAttributedString:[displayUtility addAttributedText:[currentWord actualWord] offsetCode:0 fontId:12 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
                        break;
                }
            }
            if (!(([currentWord isPrefix]) || ([[currentWord affix] compare: @""] == 0))) postfix = @" ";
            else postfix = @"";
            if ([[currentWord affix] length] > 0) theAffix = [[NSString alloc] initWithFormat:@"%@%@", zeroWidthNonJoiner, [currentWord affix]];
            else theAffix = @"";
            [singleResult appendAttributedString:[displayUtility addAttributedText:[[NSString alloc] initWithFormat:@"%@%@", theAffix, postfix] offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        }
        if (![primarySearchVerse isFollowed])
        {
            [singleResult appendAttributedString:[displayUtility addAttributedText:@"\n\n" offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        }
        else
        {
            [singleResult appendAttributedString:[displayUtility addAttributedText:@"\n" offsetCode:0 fontId:10 alignment:bhsDisplayAlignment withAdjustmentFor:bhsResultsTextView]];
        }
        [bhsSearchResults setObject:singleResult forKey:[globalVarsBHSSearch convertIntegerToString:idx]];
        bhsLatestResultCount = idx;
    }
    bhsProgressMessage = @"Search Results complete";
}

- (NSString *) createReferenceValue: (NSInteger) bookId chapter: (NSInteger) chapId verse: (NSInteger) verseId
{
    return [[NSString alloc] initWithFormat:@"%@%@%@", [self zeroPadding:bookId withNoOfPlaces:2], [self zeroPadding:chapId withNoOfPlaces:3], [self zeroPadding:verseId withNoOfPlaces:3]];
}

- (NSString *) zeroPadding: (NSInteger) sourceNumber withNoOfPlaces: (NSInteger) noOfPlaces
{
    NSInteger idx;
    NSMutableString *padding;
    NSString *finalNumber;
    
    padding = [[NSMutableString alloc] initWithString:@""];
    for( idx = 0; idx < noOfPlaces; idx++)
    {
        [padding appendString:@"0"];
    }
    finalNumber = [[NSString alloc] initWithFormat:@"%@%ld", padding, sourceNumber];
    return [[NSString alloc] initWithString:[finalNumber substringFromIndex:[finalNumber length] - noOfPlaces]];
}


@end
